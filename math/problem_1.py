# problem_1.py
# coding: utf-8
'''
一个重为40克的砝码摔成了4份，要求能用这4份砝码称出1至40克所有的质量。题目中的数据均为整数
Abstract - Algorithm


能够算出四块分别是27,9,3,1.因为任何一个1-40.都能写成A*3^3+B*3^2+C*3^1+D*3^0.
构造一个三进制的数.则1-40改为三进制数表示为(ABCD)
3.A,B,C,D表示各个数位上的数,其取值范围为{0,1,2}.
当四个数位上的数值都是0或者1时,用对应的砝码放在同一个盘称就行了,
当某个数位上的数值为2的时候,则把它前一位的砝码和其他需要的砝码放一个盘,这一位的砝码和重物放一个盘就能称.如需要称33磅,他用三进制的数表示为(1020)3,将27磅和9磅的砝码放左盘,3磅的砝码放右盘和重物放一起就能称量.另外,如前一位的数值为1或者2的时候,应该再往前推一位,如15磅,写成三进制的数为(0120),应将一个27磅的砝码放左盘,右盘放9磅和3磅的砝码,加上重物就能称量了.
这是利用了3的N次方,通过加减运算能表示仍一个正整数的原理.
为什么呢,刚才构造的三进制的数是能表示任一个正整数的,当进行减法运算的时候,
就可以表示成该数位上的数为-1.也就意味着,他的前一个数位应该加1,而这个数位的数值变成了2.
这样3的N次方加减后,得到的数,能够表示成三进制数的形式,所以也就能表示任一个正整数了
'''
'''
status = [1, 0, -1]

for w1 in range(1,40):
	for w2 in range(1,40):
		for w3 in range(1,40):
			for w4 in range(1,40-w1-w2-w3):
				for x1 in status:
					for x2 in status:
						for x3 in status:
							for x4 in status:
								if w1*x1+w2*x2 + w3*x3 + w4*x4 in range(1,41):
									print w1, w2, w3, w4
not allow so many loops									
'''
status = [-1,0,1]
weight = [27,9,3,1]
whole = []
for w1 in status:
	for w2 in status:
		for w3 in status:
			for w4 in status:
				whole.append(w1*27+w2*9 + w3*3 + w4*1)
print set(whole)